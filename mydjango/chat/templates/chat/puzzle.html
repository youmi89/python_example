
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        ì´ë¯¸ì§€ ìŠ¬ë¼ì´ë”© í¼ì¦ ê²Œì„
        {{ image_url }}
    </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .puzzle-piece {
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            touch-action: none;
            box-shadow: inset 0 0 3px rgba(0,0,0,0.4);
        }
        .puzzle-piece:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3), inset 0 0 3px rgba(0,0,0,0.4);
        }
        .empty-space {
            background: linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
                        linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
                        linear-gradient(45deg, transparent 75%, #f0f0f0 75%), 
                        linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        .shuffle-animation {
            transition: all 0.2s ease-in-out;
        }
        .game-board {
            max-width: min(90vw, 90vh);
            aspect-ratio: 1;
        }
        .piece-moving {
            z-index: 10;
            transform: scale(1.1);
            box-shadow: 0 8px 16px rgba(0,0,0,0.4);
        }
        .shake {
            animation: shake 0.3s;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-8px); }
            75% { transform: translateX(8px); }
        }
        .grayscale {
            filter: grayscale(100%);
            opacity: 0.7;
        }
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
        .bounce {
            animation: bounce 2s infinite;
        }
        .game-start-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.5rem;
            z-index: 20;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-400 via-purple-500 to-pink-500 min-h-screen p-4">
    <div class="container mx-auto max-w-4xl">
        <!-- ê²Œì„ í—¤ë” -->
        <div class="bg-white/90 backdrop-blur-sm rounded-xl p-6 mb-6 shadow-lg">
            <h1 class="text-3xl font-bold text-center text-gray-800 mb-4">ğŸ§© ì´ë¯¸ì§€ ìŠ¬ë¼ì´ë”© í¼ì¦</h1>
            
            <!-- ê²Œì„ ì •ë³´ -->
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                <div class="bg-blue-100 rounded-lg p-3">
                    <div class="text-2xl font-bold text-blue-600" id="timer">00:00</div>
                    <div class="text-sm text-blue-500">ì‹œê°„</div>
                </div>
                <div class="bg-green-100 rounded-lg p-3">
                    <div class="text-2xl font-bold text-green-600" id="moves">0</div>
                    <div class="text-sm text-green-500">ì´ë™íšŸìˆ˜</div>
                </div>
                <div class="bg-purple-100 rounded-lg p-3">
                    <div class="text-2xl font-bold text-purple-600" id="grid-size">3Ã—3</div>
                    <div class="text-sm text-purple-500">ë‚œì´ë„</div>
                </div>
                <div class="bg-yellow-100 rounded-lg p-3">
                    <div class="text-2xl font-bold text-yellow-600" id="score">0</div>
                    <div class="text-sm text-yellow-500">ì ìˆ˜</div>
                </div>
            </div>
        </div>

        <!-- ê²Œì„ ë³´ë“œ -->
        <div class="flex flex-col lg:flex-row gap-6">
            <!-- í¼ì¦ ì˜ì—­ -->
            <div class="flex-1">
                <div class="bg-white/90 backdrop-blur-sm rounded-xl p-6 shadow-lg">
                    <div id="puzzle-container" class="game-board mx-auto bg-gray-400 rounded-lg p-1 border-4 border-gray-500 relative">
                        <div id="puzzle-board" class="w-full h-full grid gap-0.5">
                            <!-- í¼ì¦ ì¡°ê°ë“¤ì´ ì—¬ê¸°ì— ìƒì„±ë©ë‹ˆë‹¤ -->
                        </div>
                        <div id="game-start-overlay" class="game-start-overlay">
                            <div class="text-white text-center">
                                <p class="text-2xl font-bold mb-2">ğŸ® ê²Œì„ ì¤€ë¹„ ì™„ë£Œ!</p>
                                <p class="text-lg">ì‹œì‘ ë²„íŠ¼ì„ í´ë¦­í•´ì£¼ì„¸ìš”</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ì»¨íŠ¸ë¡¤ ë²„íŠ¼ -->
                    <div class="flex flex-wrap justify-center gap-3 mt-6">
                        <button id="start-btn" class="bg-green-500 hover:bg-green-600 text-white px-8 py-3 rounded-lg font-semibold transition-colors text-lg">
                            â–¶ï¸ ì‹œì‘
                        </button>
                        <button id="quit-btn" class="bg-red-500 hover:bg-red-600 text-white px-8 py-3 rounded-lg font-semibold transition-colors text-lg hidden">
                            â¹ï¸ í¬ê¸°
                        </button>
                        <button id="hint-btn" class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg font-semibold transition-colors">
                            ğŸ’¡ íŒíŠ¸
                        </button>
                    </div>
                </div>
            </div>

            <!-- ì°¸ê³  ì´ë¯¸ì§€ ë° ì •ë³´ -->
            <div class="lg:w-80">
                <div class="bg-white/90 backdrop-blur-sm rounded-xl p-6 shadow-lg">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">ğŸ–¼ï¸ ì›ë³¸ ì´ë¯¸ì§€</h3>
                    <div class="relative">
                        <img id="reference-image" src="" alt="ì›ë³¸ ì´ë¯¸ì§€" class="w-full rounded-lg shadow-md">
                        <div id="hint-overlay" class="absolute inset-0 bg-black/70 rounded-lg flex items-center justify-center text-white text-lg font-semibold opacity-0 transition-opacity duration-300">
                            íŒíŠ¸ í‘œì‹œ ì¤‘...
                        </div>
                    </div>
                    
                    <!-- ìµœê³  ê¸°ë¡ -->
                    <div class="mt-6 space-y-2">
                        <h4 class="font-semibold text-gray-700">ğŸ† ìµœê³  ê¸°ë¡</h4>
                        <div class="text-sm space-y-1">
                            <div class="flex justify-between">
                                <span>3Ã—3:</span>
                                <span id="best-3x3" class="font-semibold">-</span>
                            </div>
                            <div class="flex justify-between">
                                <span>4Ã—4:</span>
                                <span id="best-4x4" class="font-semibold">-</span>
                            </div>
                            <div class="flex justify-between">
                                <span>5Ã—5:</span>
                                <span id="best-5x5" class="font-semibold">-</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ì™„ì„± ì¶•í•˜ ëª¨ë‹¬ -->
    <div id="success-modal" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 opacity-0 pointer-events-none transition-opacity duration-300">
        <div class="bg-white rounded-2xl p-8 max-w-sm mx-4 text-center transform scale-90 transition-transform duration-300">
            <div class="text-6xl mb-4">ğŸ‰</div>
            <h2 class="text-2xl font-bold text-gray-800 mb-4">í¼ì¦ ì™„ì„±!</h2>
            <div class="space-y-2 text-gray-600 mb-6">
                <div>ì™„ë£Œ ì‹œê°„: <span id="final-time" class="font-semibold"></span></div>
                <div>ì´ë™ íšŸìˆ˜: <span id="final-moves" class="font-semibold"></span></div>
                <div class="text-lg">ì ìˆ˜: <span id="final-score" class="font-bold text-blue-600"></span></div>
            </div>
            <div class="flex gap-3">
                <button id="modal-new-game" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 rounded-lg font-semibold transition-colors">
                    ìƒˆ ê²Œì„
                </button>
                <button id="modal-leaderboard" class="flex-1 bg-purple-500 hover:bg-purple-600 text-white py-2 rounded-lg font-semibold transition-colors">
                    ğŸ† ë¦¬ë”ë³´ë“œ
                </button>
                <button id="modal-close" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 rounded-lg font-semibold transition-colors">
                    ë‹«ê¸°
                </button>
            </div>
        </div>
    </div>

    <canvas id="image-canvas" style="display: none;"></canvas>

    <script>
        // íš¨ê³¼ìŒ ê´€ë¦¬ë¥¼ ìœ„í•œ í´ë˜ìŠ¤
        class SoundManager {
            constructor() {
                this.audioContext = null;
                this.initialized = false;
            }
            
            init() {
                if (this.initialized) return;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                } catch (e) {
                    console.log('Web Audio API not supported');
                }
            }
            
            playMoveSound() {
                if (!this.initialized) this.init();
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                // ì‚¬ì‚¬ì‚­ ì†Œë¦¬ë¥¼ ìœ„í•œ ì„¤ì •
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(400, this.audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.1);
            }
            
            playErrorSound() {
                if (!this.initialized) this.init();
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                // ì˜¤ë¥˜ ì†Œë¦¬ë¥¼ ìœ„í•œ ì„¤ì • (ë”© ì†Œë¦¬)
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.2);
            }
        }
        
        class SlidingPuzzleGame {
            constructor() {
                // ê²Œì„ ì„¤ì • (í•˜ë“œì½”ë”©)
                // this.imageUrl = './assets/mario.jpg';
                this.imageUrl = '{{ image_url }}';
                this.gridSize = {{ level }}; // 3x3, 4x4, 5x5 ì¤‘ ì„ íƒ (í•˜ë“œì½”ë”©)
                
                // ê²Œì„ ìƒíƒœ
                this.pieces = [];
                this.emptyIndex = 0;
                this.moves = 0;
                this.startTime = null;
                this.gameTimer = null;
                this.isGameActive = false;
                this.isShuffling = false;
                this.isGameStarted = false;
                
                // íš¨ê³¼ìŒ ê´€ë¦¬ì
                this.soundManager = new SoundManager();
                
                // DOM ìš”ì†Œë“¤
                this.puzzleBoard = document.getElementById('puzzle-board');
                this.timerDisplay = document.getElementById('timer');
                this.movesDisplay = document.getElementById('moves');
                this.scoreDisplay = document.getElementById('score');
                this.gridSizeDisplay = document.getElementById('grid-size');
                this.referenceImage = document.getElementById('reference-image');
                this.gameStartOverlay = document.getElementById('game-start-overlay');
                this.startButton = document.getElementById('start-btn');
                
                this.init();
            }

            async init() {
                this.setupEventListeners();
                this.updateGridSizeDisplay();
                await this.loadImage();
                this.createPuzzle();
                this.loadBestScores();
                // í˜ì´ì§€ ë¡œë“œ ì‹œ ì¦‰ì‹œ ì„ê¸° (ì• ë‹ˆë©”ì´ì…˜ ì—†ì´)
                this.shufflePuzzleInstant();
                // ì´ˆê¸° ìƒíƒœ ì„¤ì •
                this.setInitialState();
            }

            setupEventListeners() {
                document.getElementById('start-btn').addEventListener('click', () => this.startGame());
                document.getElementById('quit-btn').addEventListener('click', () => this.quitGame());
                document.getElementById('hint-btn').addEventListener('click', () => this.showHint());
                document.getElementById('modal-new-game').addEventListener('click', () => location.reload());
                document.getElementById('modal-close').addEventListener('click', () => this.closeModal());
                document.getElementById('modal-leaderboard').addEventListener('click', () => window.location.href = '/leaderboard');
                
                // í„°ì¹˜ ë° ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ëŠ” í¼ì¦ ì¡°ê° ìƒì„± ì‹œ ì¶”ê°€
            }

            async loadImage() {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        this.originalImage = img;
                        this.referenceImage.src = this.imageUrl;
                        this.cropImageToSquare();
                        resolve();
                    };
                    img.src = this.imageUrl;
                });
            }

            cropImageToSquare() {
                const canvas = document.getElementById('image-canvas');
                const ctx = canvas.getContext('2d');
                
                const size = Math.min(this.originalImage.width, this.originalImage.height);
                canvas.width = size;
                canvas.height = size;
                
                const offsetX = (this.originalImage.width - size) / 2;
                const offsetY = (this.originalImage.height - size) / 2;
                
                ctx.drawImage(this.originalImage, offsetX, offsetY, size, size, 0, 0, size, size);
                this.croppedImageData = canvas.toDataURL();
            }

            createPuzzle() {
                this.pieces = [];
                this.puzzleBoard.innerHTML = '';
                this.puzzleBoard.className = `w-full h-full grid gap-0.5 grid-cols-${this.gridSize}`;
                
                const totalPieces = this.gridSize * this.gridSize;
                this.emptyIndex = totalPieces - 1; // ë§ˆì§€ë§‰ ì¡°ê°ì´ ë¹ˆ ê³µê°„
                
                for (let i = 0; i < totalPieces; i++) {
                    const piece = this.createPuzzlePiece(i);
                    this.pieces.push(piece);
                    this.puzzleBoard.appendChild(piece);
                }
                
                this.resetGameStats();
            }

            createPuzzlePiece(index) {
                const piece = document.createElement('div');
                piece.className = 'puzzle-piece relative overflow-hidden border border-gray-600';
                piece.style.aspectRatio = '1';
                piece.dataset.index = index;
                piece.dataset.currentPosition = index;
                
                if (index === this.emptyIndex) {
                    piece.className += ' empty-space';
                } else {
                    this.setPieceBackground(piece, index);
                    this.addPieceEventListeners(piece);
                }
                
                return piece;
            }

            setPieceBackground(piece, index) {
                const row = Math.floor(index / this.gridSize);
                const col = index % this.gridSize;
                
                piece.style.backgroundImage = `url(${this.croppedImageData})`;
                piece.style.backgroundSize = `${this.gridSize * 100}% ${this.gridSize * 100}%`;
                piece.style.backgroundPosition = `-${col * 100}% -${row * 100}%`;
            }

            addPieceEventListeners(piece) {
                // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
                piece.addEventListener('click', (e) => this.handlePieceClick(e));
                
                // í„°ì¹˜ ì´ë²¤íŠ¸
                piece.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handlePieceClick(e);
                }, { passive: false });
                
                // ë“œë˜ê·¸ ë°©ì§€
                piece.addEventListener('dragstart', (e) => e.preventDefault());
            }

            handlePieceClick(event) {
                if (this.isShuffling || !this.isGameActive || !this.isGameStarted) return;
                
                const piece = event.currentTarget;
                const clickedIndex = Array.from(this.puzzleBoard.children).indexOf(piece);
                
                if (this.canMovePiece(clickedIndex)) {
                    this.soundManager.playMoveSound();
                    this.movePiece(clickedIndex);
                    this.moves++;
                    this.updateMoves();
                    
                    if (this.checkWin()) {
                        this.gameWon();
                    }
                } else {
                    // ì´ë™í•  ìˆ˜ ì—†ëŠ” ë¸”ë¡ í´ë¦­ ì‹œ
                    this.soundManager.playErrorSound();
                    piece.classList.add('shake');
                    setTimeout(() => piece.classList.remove('shake'), 300);
                }
            }

            canMovePiece(position) {
                const emptyPos = this.findEmptyPosition();
                const row = Math.floor(position / this.gridSize);
                const col = position % this.gridSize;
                const emptyRow = Math.floor(emptyPos / this.gridSize);
                const emptyCol = emptyPos % this.gridSize;
                
                return (Math.abs(row - emptyRow) === 1 && col === emptyCol) || 
                       (Math.abs(col - emptyCol) === 1 && row === emptyRow);
            }

            movePiece(position) {
                const emptyPos = this.findEmptyPosition();
                const movingPiece = this.pieces[position];
                const emptyPiece = this.pieces[emptyPos];
                
                // ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼
                movingPiece.classList.add('piece-moving');
                setTimeout(() => movingPiece.classList.remove('piece-moving'), 300);
                
                // ë°°ì—´ì—ì„œ ìœ„ì¹˜ êµí™˜
                this.pieces[position] = emptyPiece;
                this.pieces[emptyPos] = movingPiece;
                
                // dataset ì—…ë°ì´íŠ¸
                movingPiece.dataset.currentPosition = emptyPos;
                emptyPiece.dataset.currentPosition = position;
                
                // DOM ì¬ë°°ì¹˜
                this.renderPuzzle();
            }

            findEmptyPosition() {
                for (let i = 0; i < this.pieces.length; i++) {
                    if (this.pieces[i].classList.contains('empty-space')) {
                        return i;
                    }
                }
                return -1;
            }
            
            renderPuzzle() {
                this.puzzleBoard.innerHTML = '';
                this.pieces.forEach(piece => {
                    this.puzzleBoard.appendChild(piece);
                });
            }

            async shufflePuzzle() {
                if (this.isShuffling) return;
                
                this.isShuffling = true;
                this.isGameActive = false;
                
                // 3ì´ˆ ë™ì•ˆ ì• ë‹ˆë©”ì´ì…˜ê³¼ í•¨ê»˜ ì„ê¸°
                const shuffleCount = 100; // ì´ ì„ê¸° íšŸìˆ˜
                const shuffleInterval = 30; // 30ms ê°„ê²©
                
                for (let i = 0; i < shuffleCount; i++) {
                    await new Promise(resolve => {
                        setTimeout(() => {
                            this.makeRandomMove();
                            resolve();
                        }, shuffleInterval);
                    });
                }
                
                this.isShuffling = false;
                this.isGameActive = true;
            }
            
            shufflePuzzleInstant() {
                // ì• ë‹ˆë©”ì´ì…˜ ì—†ì´ ì¦‰ì‹œ ì„ê¸°
                const shuffleCount = 100;
                
                for (let i = 0; i < shuffleCount; i++) {
                    this.makeRandomMove();
                }
                
                this.isGameActive = true;
            }

            makeRandomMove() {
                const emptyPos = this.findEmptyPosition();
                const possibleMoves = [];
                
                const row = Math.floor(emptyPos / this.gridSize);
                const col = emptyPos % this.gridSize;
                
                // ìƒí•˜ì¢Œìš° ì¸ì ‘í•œ ì¡°ê°ë“¤ ì°¾ê¸°
                if (row > 0) possibleMoves.push((row - 1) * this.gridSize + col);
                if (row < this.gridSize - 1) possibleMoves.push((row + 1) * this.gridSize + col);
                if (col > 0) possibleMoves.push(row * this.gridSize + (col - 1));
                if (col < this.gridSize - 1) possibleMoves.push(row * this.gridSize + (col + 1));
                
                if (possibleMoves.length > 0) {
                    const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    this.movePiece(randomMove);
                }
            }

            startGame() {
                if (this.isGameStarted) return;
                
                this.resetGameStats();
                this.isGameActive = true;
                this.isGameStarted = true;
                this.startTime = Date.now();
                this.gameTimer = setInterval(() => this.updateTimer(), 100);
                
                // ë²„íŠ¼ ìƒíƒœ ë³€ê²½
                document.getElementById('start-btn').classList.add('hidden');
                document.getElementById('quit-btn').classList.remove('hidden');
                
                // ê²Œì„ ì‹œì‘ ì‹œ íšŒìƒ‰ í•„í„° ì œê±°
                this.puzzleBoard.classList.remove('grayscale');
                this.gameStartOverlay.classList.add('hidden');
                this.startButton.classList.remove('bounce');
            }
            
            quitGame() {
                this.isGameActive = false;
                this.isGameStarted = false;
                
                if (this.gameTimer) {
                    clearInterval(this.gameTimer);
                    this.gameTimer = null;
                }
                
                // ë²„íŠ¼ ìƒíƒœ ë³€ê²½
                document.getElementById('start-btn').classList.remove('hidden');
                document.getElementById('quit-btn').classList.add('hidden');
                
                // íƒ€ì´ë¨¸ì™€ ì ìˆ˜ ì´ˆê¸°í™”
                this.timerDisplay.textContent = '00:00';
                this.scoreDisplay.textContent = '0';
                
                // íšŒìƒ‰ í•„í„° ë‹¤ì‹œ ì ìš©
                this.puzzleBoard.classList.add('grayscale');
                this.gameStartOverlay.classList.remove('hidden');
                this.startButton.classList.add('bounce');
            }

            resetGameStats() {
                this.moves = 0;
                this.startTime = null;
                if (this.gameTimer) {
                    clearInterval(this.gameTimer);
                    this.gameTimer = null;
                }
                this.updateMoves();
                this.updateTimer();
                this.updateScore();
            }

            updateMoves() {
                this.movesDisplay.textContent = this.moves;
                this.updateScore();
            }

            updateTimer() {
                if (!this.startTime) {
                    this.timerDisplay.textContent = '00:00';
                    return;
                }
                
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                this.timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            updateScore() {
                if (!this.startTime) {
                    this.scoreDisplay.textContent = '0';
                    return;
                }
                
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const baseScore = 10000;
                const timePenalty = elapsed * 10;
                const movePenalty = this.moves * 50;
                const difficultyBonus = this.gridSize * 100;
                
                const score = Math.max(0, baseScore - timePenalty - movePenalty + difficultyBonus);
                this.scoreDisplay.textContent = score;
            }

            checkWin() {
                return this.pieces.every((piece, index) => {
                    const originalIndex = parseInt(piece.dataset.index);
                    return originalIndex === index;
                });
            }

            gameWon() {
                this.isGameActive = false;
                clearInterval(this.gameTimer);
                
                const finalTime = Math.floor((Date.now() - this.startTime) / 1000);
                const finalScore = parseInt(this.scoreDisplay.textContent);
                
                // ìµœê³  ê¸°ë¡ ì—…ë°ì´íŠ¸
                this.updateBestScore(finalScore);
                
                // ê²Œì„ ë°ì´í„° ìˆ˜ì§‘
                const gameData = {
                    gridSize: this.gridSize,
                    moves: this.moves,
                    timeSeconds: finalTime,
                    score: finalScore,
                    completedAt: new Date().toISOString()
                };
                
                // ìˆ¨ê²¨ì§„ form ìƒì„±
                const form = document.createElement('form');
                form.method = 'POST';
                form.action = '/leaderboard/submit';
                form.style.display = 'none';
                
                // form ë°ì´í„° ì¶”ê°€
                Object.keys(gameData).forEach(key => {
                    const input = document.createElement('input');
                    input.type = 'hidden';
                    input.name = key;
                    input.value = gameData[key];
                    form.appendChild(input);
                });
                
                // formì„ bodyì— ì¶”ê°€í•˜ê³  submit
                document.body.appendChild(form);
                setTimeout(() => form.submit(), 1000); // 1ì´ˆ í›„ submitìœ¼ë¡œ ì¶•í•˜ í™”ë©´ ë³´ì—¬ì£¼ê¸°
                
                // ì¶•í•˜ ëª¨ë‹¬ í‘œì‹œ
                this.showSuccessModal(finalTime, this.moves, finalScore);
            }

            showSuccessModal(time, moves, score) {
                const modal = document.getElementById('success-modal');
                const minutes = Math.floor(time / 60);
                const seconds = time % 60;
                
                document.getElementById('final-time').textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('final-moves').textContent = moves;
                document.getElementById('final-score').textContent = score;
                
                modal.classList.remove('opacity-0', 'pointer-events-none');
                modal.querySelector('.bg-white').classList.remove('scale-90');
                modal.querySelector('.bg-white').classList.add('scale-100');
            }

            closeModal() {
                const modal = document.getElementById('success-modal');
                modal.classList.add('opacity-0', 'pointer-events-none');
                modal.querySelector('.bg-white').classList.add('scale-90');
                modal.querySelector('.bg-white').classList.remove('scale-100');
            }

            showHint() {
                if (!this.isGameStarted) return;
                
                const overlay = document.getElementById('hint-overlay');
                overlay.classList.remove('opacity-0');
                setTimeout(() => {
                    overlay.classList.add('opacity-0');
                }, 2000);
            }

            newGame() {
                this.closeModal();
                this.isGameStarted = false;
                this.isGameActive = false;
                
                // ë²„íŠ¼ ìƒíƒœ ì´ˆê¸°í™”
                document.getElementById('start-btn').classList.remove('hidden');
                document.getElementById('quit-btn').classList.add('hidden');
                
                this.createPuzzle();
                this.shufflePuzzleInstant();
                
                // ì´ˆê¸° ìƒíƒœ ì„¤ì •
                this.setInitialState();
            }
            
            setInitialState() {
                // ì´ˆê¸° ìƒíƒœ: íšŒìƒ‰ í•„í„°, ì‹œì‘ ë²„íŠ¼ bounce
                this.puzzleBoard.classList.add('grayscale');
                this.startButton.classList.add('bounce');
                this.gameStartOverlay.classList.remove('hidden');
            }

            updateGridSizeDisplay() {
                this.gridSizeDisplay.textContent = `${this.gridSize}Ã—${this.gridSize}`;
            }

            updateBestScore(score) {
                const key = `best-${this.gridSize}x${this.gridSize}`;
                const currentBest = localStorage.getItem(key);
                
                if (!currentBest || score > parseInt(currentBest)) {
                    localStorage.setItem(key, score);
                    this.loadBestScores();
                }
            }

            loadBestScores() {
                const sizes = [3, 4, 5];
                sizes.forEach(size => {
                    const key = `best-${size}x${size}`;
                    const score = localStorage.getItem(key);
                    const element = document.getElementById(`best-${size}x${size}`);
                    element.textContent = score || '-';
                });
            }
        }

        // ê²Œì„ ì‹œì‘
        document.addEventListener('DOMContentLoaded', () => {
            new SlidingPuzzleGame();
        });
    </script>
</body>
</html>
